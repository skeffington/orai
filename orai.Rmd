---
title: "Orai channel evolution in Haptophytes"
output: html_notebook
---

```{r}
library(tidyverse)
library(magrittr)
library(data.table)
library(ggtree)
#library(msa)

library(DECIPHER)
#library(microseq)
library(ape)
library(plotly)
library(ggmsa)
```

Key links for phylogeny:




Step 1: Gather a collection of bone-fide Orai proteins from across ToL

Emihu2_haploid_allproteins_sn.fasta          EP00324_Dicrateria_rotunda.fasta
EP00006_Acanthamoeba_castellanii.fasta       EP00325_Prymnesiales_sp_UTEX-LB-985.fasta
EP00024_Dictyostelium_purpureum.fasta        EP00326_Haptolina_ericina.fasta
EP00046_Monosiga_brevicollis.fasta           EP00327_Prymnesium_parvum.fasta
EP00134_Neurospora_crassa.fasta              EP00425_Heterocapsa_triquetra.fasta
EP00136_Aspergillus_niger.fasta              EP00427_Karlodinium_veneficum.fasta
EP00144_Saccharomyces_cerevisiae.fasta       EP00428_Durinskia_dybowskii.fasta
EP00163_Fabomonas_tropica.fasta              EP00429_Kryptoperidinium_foliaceum.fasta
EP00164_Ancoracysta_twista.fasta             EP00480_Reticulomyxa_filosa.fasta
EP00185_Porphyridium_purpureum.fasta         EP00530_Phaeodactylum_tricornutum.fasta
EP00198_Chlamydomonas_reinhardtii.fasta      EP00582_Thalassiosira_oceanica.fasta
EP00202_Volvox_carteri.fasta                 EP00656_Telonema_subtile.fasta
EP00224_Ostreococcus_tauri.fasta             EP00682_Trypanosoma_cruzi.fasta
EP00298_Acanthocystis_sp_HF-20.fasta         EP00696_Hemimastix_kukwesjijk.fasta
EP00299_Pterocystis_sp_00344.fasta           EP00697_Spironema_sp_BW2.fasta
EP00300_Choanocystis_sp_HF-7.fasta           EP00770_Monocercomonoides_exilis.fasta
EP00301_Raphidiophrys_heterophryoidea.fasta  EP00797_Seminavis_robusta.fasta
EP00302_Diacronema_sp_CCMP2436.fasta         EP00822_Plasmodium_yoelii.fasta
EP00303_Exanthemachrysis_gayraliae.fasta     EP00829_Urostomides_striatus.fasta
EP00304_Pavlova_gyrans.fasta                 EP00900_Chrysochromulina_parva.fasta
EP00306_Pavlova_sp_CCMP459.fasta             EP00908_Phaeocystis_cordata.fasta
EP00307_Rebecca_sp_RCC1486.fasta             EP00934_Nitzschia_sp_Nitz4.fasta
EP00308_Calcidiscus_leptoporus.fasta         EP00962_Isochrysis_galbana.fasta
EP00310_Coccolithus_braarudii.fasta          EP00963_Diacronema_lutheri.fasta
EP00312_Isochrysidales_sp_CCMP1244.fasta     EP00964_Phaeocystis_antarctica.fasta
EP00314_Emiliania_huxleyi.fasta              EP00965_Chrysotila_dentata.fasta
EP00315_Gephyrocapsa_oceanica.fasta          EP00966_Prymnesium_polylepis.fasta
EP00316_Scyphosphaera_apsteinii.fasta        EP00967_Tisochrysis_lutea.fasta
EP00320_Phaeocystis_rex.fasta                EP00977_Amphora_coffeiformis.fasta
EP00322_Chrysochromulina_rotalis.fasta       EP01082_Thalassiosira_pseudonana.fasta
EP00323_Chrysochromulina_tobinii.fasta       Phaglo1_GeneCatalog_proteins_20181013.aa.fasta


D malanogaster
Human Orai 1, 2, 3
C elegans
Danio rerio
C reinhardii ??
Physcomatrella patans
T pseudonana
Haptophyte sequences from across Danijela's tree

```{r}

orai_sel<-readAAStringSet("orai_select.fasta")
```

```{#r}
orai_sel_aln<-msa(orai_sel, method="Muscle")
print(orai_sel_aln, show="complete")

msaPrettyPrint(orai_sel_aln, output="pdf", showNames="left", showLogo="none", askForOverwrite=FALSE, verbose=FALSE)

msaPrettyPrint(orai_sel_aln, y=c(164, 213), output="asis", showNames="left", showLogo="none", askForOverwrite=FALSE)

ggmsa(orai_sel, 300, 350, color = "Clustal", font = "DroidSansMono", char_width = 0.5, seq_name = TRUE )

p <- ggmsa(protein_sequences, 300, 350, char_width = 0.5, seq_name = TRUE) + geom_msaBar()
ggsave("p.png",p, height = 2,width = 8)
```



```{r}

orai_sel_daln<-AlignSeqs(orai_sel)
orai_sel_daln_adj <- AdjustAlignment(orai_sel_daln)
BrowseSeqs(orai_sel_daln_adj, highlight=0)
writeXStringSet(orai_sel_daln_adj, "orai_sel_sln.fasta")

orai_sel_alnfa<-readFasta("orai_sel_sln.fasta")
orai_sel_trim<-msaTrim(orai_sel_alnfa, gap.end= 0.5, gap.mid = 1)
writeFasta(orai_sel_trim, "orai_sel_sln_trim.fasta")

orai_trim<-readAAStringSet("orai_sel_sln_trim.fasta")
orai_sel_daln_adj_trim_adj <- AdjustAlignment(orai_trim)
BrowseSeqs(orai_sel_daln_adj_trim_adj, highlight=0)

```

MAFT = 
L-INS-i (Probably most accurate, very slow)
% mafft --reorder --dash --originalseqonly --auto input 


MAFT dash =
L-INS-i (Probably most accurate, very slow) 
 mafft-homologs.rb -N 8 -l -d uniref50 -o '--reorder --dash --originalseqonly --auto' -a 50 -e 1.0e-30 -s input 


```{r}
orai_maft<-readAAStringSet("orai_sel_maft.fasta")
BrowseSeqs(orai_maft, highlight=0)

BrowseSeqs(orai_maft, patterns=c("[MFL][VL]E", "LAEV"), colors = c("#74eb34", "#94d9eb"))

domains=c(Basic1 = "SRA",
          Basic2 = "LKA",
          Basic3 = "SRT",
          hyd1 = "ALL",
          hyd2 = "GFA",
          hyd3 = "MVA",
          sel1 = "VEV",
          sel2 = "LAEV",
          CAR = "DADHD",
          ETON = "ALSWRKLYLSRAKLKAS",
          TM4bend="MVPF",
          TM4ex = "RQFQE")

colset = c(rep("#ace34d", 3), rep("#85898f", 3), rep("#e82f1e", 2), "#f2e15e", "#67cee0", "#2c7cc7", "#913bed")

BrowseSeqs(orai_maft, patterns=domains, colors = colset)


```

Pore region: Basic domain R83, K87, R91 + hydrophobic L95, F99, and V102 + selectivity: E106
First extracellular loop: D110, D112, D114 : calcium accumulating (CAR: ensures works in low Ca conditions)
ETON: an alpha helix of the TM1 domain extends to cytoplasm and requried for STIM1 association and channel gaing.
TM4 extended region: 268 -291: association of neighboring subunits. RQFQELNELAEFARLQDQLDHRG.
C-terminal is main STIM one binding site
Prolein 245 is required for hte kink in TM4


```{}

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; mmseqs createdb $i $NAME; done

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; OUT=$(basename $i .fasta)_SERDB; mmseqs search ../../psiDB $NAME $OUT tmp --num-iterations 12 -s 7.5 -e 1.000E-02; rm -r tmp; done

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; OUT=$(basename $i .fasta)_SERDB; TSV=$(basename $i .fasta)_search.tab; mmseqs convertalis ../../psiDB $NAME $OUT $TSV; done

#Try more prots (seq4psi_fulllen.fasta) and full length. Only proteins confirmed with the conserved E106 as bait:

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; OUT=$(basename $i .fasta)_FLDB; mmseqs search ../../psiFL $NAME $OUT tmp --num-iterations 10 -s 7.5 -e 1.000E-01; rm -r tmp; done

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; OUT=$(basename $i .fasta)_FLDB; TSV=$(basename $i .fasta)_searchFL.tab; mmseqs convertalis ../../psiFL $NAME $OUT $TSV; done



```



Download from Interpro fasta files of :



And create profiles with mmseqs

```{}
mmseqs linclust cracIPDB cracIPDBclus tmp
mmseqs createsubdb cracIPDBclus cracIPDB sequenceRepDb
mmseqs createsubdb cracIPDBclus cracIPDB_h sequenceRepDb_h
mmseqs result2profile sequenceRepDb cracIPDB cracIPDBclus cracIP_ProfileDb


mmseqs linclust oraiSFDB oraiSFDBclus tmp
mmseqs createsubdb oraiSFDBclus oraiSFDB sequenceRepDb
mmseqs createsubdb oraiSFDBclus oraiSFDB_h sequenceRepDb_h
mmseqs result2profile sequenceRepDb oraiSFDB oraiSFDBclus oraiSF_ProfileDb

```


Now do profile searches against the databases

```{}

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; OUT=$(basename $i .fasta)_oraiSF_profSDB; mmseqs search /data2/orai/oraiSFip/oraiSF_ProfileDb $NAME $OUT tmp --num-iterations 3 -e 1.000E-02 -s 7.5; rm -r tmp; done

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; OUT=$(basename $i .fasta)_oraiSF_profSDB; TSV=$(basename $i .fasta)_oraiSF_profS.tab; mmseqs convertalis /data2/orai/oraiSFip/oraiSF_ProfileDb $NAME $OUT $TSV; done

mv *_oraiSF_profSDB* *oraiSF_profS.tab oraiSF_profile_search

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; OUT=$(basename $i .fasta)_cracF_profSDB; mmseqs search /data2/orai/cracip/cracIP_ProfileDb $NAME $OUT tmp --num-iterations 3 -e 1.000E-02 -s 7.5; rm -r tmp; done

for i in *.fasta; do NAME=$(basename $i .fasta)_DB; OUT=$(basename $i .fasta)_cracF_profSDB; TSV=$(basename $i .fasta)_cracF_profS.tab; mmseqs convertalis /data2/orai/cracip/cracIP_ProfileDb $NAME $OUT $TSV; done

mv *cracF_profSDB* *cracF_profS.tab cracF_profile_searc

#Looking at E hux results, even very low pid hits have orai pfam annotations...

##Finally use hmmer to do serach against pfam profile:

for i in *.fasta; do OUT=$(basename $i .fasta)_PF07856_hits.txt; OUT2=$(basename $i .fasta)_PF07856_output.txt; hmmsearch -E 1E-02 --cpu 30 --tblout $OUT --noali /data2/orai/crac.hmm $i > $OUT2 ; done

```


Danijela's sequences found via proteomics are not explicity in the braaruddii proteome here, so repeat all analyses on this set:

```{}

mmseqs search ../psiDB sturmBraDB sturm_orai_SERDB tmp --num-iterations 12 -s 7.5 -e 1.000E-02
mmseqs convertalis ../psiDB sturmBraDB sturm_orai_SERDB sturm_orai_search.tab

mmseqs search ../psiFL sturmBraDB sturm_orai_FLDB tmp --num-iterations 12 -s 7.5 -e 1.000E-02
mmseqs convertalis ../psiFL sturmBraDB sturm_orai_FLDB sturm_orai_searchFL.tab

mmseqs search /data2/orai/oraiSFip/oraiSF_ProfileDb sturmBraDB sturm_orai_oraiSF_profSDB tmp --num-iterations 3 -e 1.000E-02 -s 7.5
mmseqs convertalis /data2/orai/oraiSFip/oraiSF_ProfileDb sturmBraDB sturm_orai_oraiSF_profSDB sturm_orai_oraiSF_profS.tab

mmseqs search /data2/orai/cracip/cracIP_ProfileDb sturmBraDB sturm_orai_cracF_profSDB tmp --num-iterations 3 -e 1.000E-02 -s 7.5
mmseqs convertalis /data2/orai/cracip/cracIP_ProfileDb sturmBraDB sturm_orai_cracF_profSDB sturm_orai_ocracF_profS.tab

hmmsearch -E 1E-02 --cpu 30 --tblout sturm_orai_PF07856_hits.txt --noali /data2/orai/crac.hmm sturm_braarudii_orai.fasta > sturm_orai_PF07856_output.txt

#mv to appropriate output folders.
```

cat to single results file for each search type.

Now read all results and make a bit table of hits across all species, one row per protein


```{r}

#perl -p -e 's/(^([^\s]*\s*){17}).*$/$1/g' All_PF07856_hits.txt > All_PF07856_hits_v2.txt

PFhits<-fread("/data2/orai/proteomes/chosen/05_PF07856_hits/All_PF07856_hits_v3.txt", sep=" ", header=FALSE)
TMpsi<-fread("/data2/orai/proteomes/chosen/01_TMregion_psi_search/All_TMregion_psi_search.tab")
FLpsi<-fread("/data2/orai/proteomes/chosen/02_FL_psi_search/All_FL_psi_search.tab")
OraiSFpro<-fread("/data2/orai/proteomes/chosen/03_oraiSF_profile_search/All_oraiSF_profile_search.tab") %>% filter(V11 < 10^-20 & V3 > 0.7)
cracFpro<-fread("/data2/orai/proteomes/chosen/04_cracF_profile_search/All_cracF_profile_search.tab") %>% filter(V11 < 10^-20 & V3 > 0.7)


cracFpro %>% filter(V11 < 10^-20 & V3 > 0.7) %>% nrow()
OraiSFpro %>% filter(V11 < 10^-20 & V3 > 0.7) %>% nrow()


c(PFhits$V1, TMpsi$V2, FLpsi$V2, OraiSFpro$V2, cracFpro$V2) %>% as.character() %>% unique() %>% length()

selectedids<-c(PFhits$V1, TMpsi$V2, FLpsi$V2, OraiSFpro$V2, cracFpro$V2) %>% as.character() %>% unique() 
```

```{#r}
#write ID list
write.table(selectedids, file="/data2/orai/putative/selectedprot_ids.txt", sep = "\t", quote=FALSE, row.names=FALSE, col.names=FALSE)

#Make ID list namining consistent with fasta file:
#sed -i -r 's/(A0A.*)/\1_Coccolithus_braarudii/g' selectedprot_ids.txt

```

Extract sequences to fasta with seqkit grep. Fasta file in 

/data2/orai/putative/putative_orai.fasta

```{}

#cat all proteomes together
sed 's/ /_/g' sturm_braarudii_orai.fasta | sed -E 's/\[|\]//g' > sturm_braarudii_orai_sn.fasta
cat ../sturm_braarudii_orai_sn.fasta All_chosen_proteomes.fasta > All_project_proteins.fasta

seqkit grep -f selectedprot_ids.txt All_project_proteins.fasta | sed 's/*//g' | sed -r 's/>([^ ]*) .*$/>\1/g' > putative_orai.fasta 

./interproscan.sh -cpu 28 -i /data2/orai/putative/putative_orai_sn.fasta -f tsv -o orai_interpro.tsv

```


Combine analyses:


```{r}

orai_IP_oraiSF<-fread("/data2/orai/putative/orai_interpro.tsv") %>% filter(., str_detect(V13, "Orai") | str_detect(V13, "Calcium"))
orai_IP_cracF<-fread("/data2/orai/putative/orai_interpro.tsv") %>% filter(., str_detect(V13, "Calcium"))

PFhits_1<-PFhits %>% select(., V1, V5) %>% set_colnames(., c("ID", "Pfam_pval"))
cracFpro_1<-cracFpro %>% select(., V2, V11) %>% group_by(V2) %>% summarise(min=min(V11)) %>% set_colnames(., c("ID", "crac_fam_prof_search_minPval"))
OraiSFpro_1<-OraiSFpro %>% select(., V2, V11) %>% group_by(V2) %>% summarise(min=min(V11))  %>% set_colnames(., c("ID", "orai_superfam_prof_search_minPval"))
FLpsi_1<-FLpsi %>% select(., V2, V11) %>% group_by(V2) %>% summarise(min=min(V11))  %>% set_colnames(., c("ID", "true_orai_fulllen_psi_search_minPval"))
TMpsi_1<-TMpsi %>% select(., V2, V11) %>% group_by(V2) %>% summarise(min=min(V11))  %>% set_colnames(., c("ID", "true_orai_transmem_psi_search_minPval"))

Orai_initial<-full_join(PFhits_1, cracFpro_1) %>% full_join(., OraiSFpro_1) %>% full_join(., FLpsi_1) %>% full_join(., TMpsi_1)

Orai_initial<-Orai_initial %>% mutate(., IP_CRAC= Orai_initial$ID %in% orai_IP_cracF$V1)

Orai_initial<-Orai_initial %>% mutate(., IP_ORAI= Orai_initial$ID %in% orai_IP_oraiSF$V1)

Orai_initial<-Orai_initial %>% mutate(., genomic = case_when(
                         str_detect(ID, "^EhG") == TRUE ~ TRUE,
                         str_detect(ID, "^Br") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00006") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00024") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00046") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00134") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00136") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00144") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00185") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00198") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00202") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00224") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00314") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00323") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00480") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00530") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00582") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00682") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00770") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00797") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00822") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00900") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00934") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00962") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00963") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00964") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00965") == TRUE ~ TRUE,
                         str_detect(ID, "^EP00966") == TRUE ~ TRUE,
                          str_detect(ID, "^EP00967") == TRUE ~ TRUE,
                          str_detect(ID, "^EP00977") == TRUE ~ TRUE,
                          str_detect(ID, "^EP01082") == TRUE ~ TRUE,
                          str_detect(ID, "^Phaglo1") == TRUE ~ TRUE,
                         .default = FALSE
                         ))

Orai_initial<-Orai_initial %>% mutate(., hapista = case_when(
                         str_detect(ID, "^EP00006") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00024") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00046") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00134") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00136") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00144") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00163") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00185") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00198") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00202") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00224") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00298") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00425") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00427") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00428") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00429") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00480") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00530") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00582") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00656") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00682") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00696") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00697") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00770") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00979") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00822") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00829") == TRUE ~ FALSE,
                         str_detect(ID, "^EP00934") == TRUE ~ FALSE,
                          str_detect(ID, "^EP00977") == TRUE ~ FALSE,
                          str_detect(ID, "^EP001082") == TRUE ~ FALSE,
                         .default = TRUE))

#remove unreasonably long chlamy prot (there is still another)
Orai_initial<-Orai_initial %>% filter(., ! ID == "EP00198_Chlamydomonas_reinhardtii_P008565")


```


Refine protein set:

```{r}

Orai_initial %>% filter(., IP_CRAC == TRUE, IP_ORAI==TRUE ) #79
Orai_initial %>% filter(., IP_CRAC == FALSE, IP_ORAI==TRUE ) #73
Orai_initial %>% filter(., IP_CRAC == TRUE, IP_ORAI==FALSE ) #0

Orai_initial %>% filter(., IP_CRAC == FALSE, IP_ORAI==FALSE ) #287
Orai_initial_noIP<-Orai_initial %>% filter(., IP_CRAC == FALSE, IP_ORAI==FALSE,  )

Orai_initial_noIP %>% filter(., ! is.na(crac_fam_prof_search_minPval) | ! is.na(orai_superfam_prof_search_minPval) | ! is.na(true_orai_transmem_psi_search_minPval))

#So there are some reasonable candidates not identified by interpro as Orai SF. 
#Full length psi searches finds a lot of additional candidates compared to transmembrane psi searches
#there are a number of proteins where the only evidence is a weak full length psi hit. Or with only weak pfam hit
```

```{#r}
#Define 2 protein sets:

#set1: Interpro Orai only: 152 proteins (incluing Ehux isoforms)

Orai_initial_IPORAI<-Orai_initial %>% filter(., IP_ORAI ==TRUE) 
Orai_set1<-Orai_initial %>% filter(., IP_ORAI ==TRUE) %>% filter(., ! ID %in% ehuxisos)  %>% .$ID
write.table(Orai_set1, file="/data2/orai/putative/Orai_set1prot_ids.txt", sep = "\t", quote=FALSE, row.names=FALSE, col.names=FALSE)

#set1 genomic:

ehuxisos<-c("EhG16802.2","EhG16802.3","EhG16802.4","EhG28556.4","EhG40991.4","EhG26343.2")

Orai_set1_genomic<-Orai_initial %>% filter(., IP_ORAI ==TRUE) %>% filter(., genomic == TRUE) %>% filter(., ! ID %in% ehuxisos) %>%  .$ID
write.table(Orai_set1_genomic, file="/data2/orai/putative/Orai_set1_genomic_ids.txt", sep = "\t", quote=FALSE, row.names=FALSE, col.names=FALSE)

#set 1 haptophyte:

Orai_set1_hapto<-Orai_initial %>% filter(., IP_ORAI ==TRUE) %>% filter(., hapista == TRUE) %>% filter(., ! ID %in% ehuxisos) %>%  .$ID
write.table(Orai_set1_hapto, file="/data2/orai/putative/Orai_set1_hapista_ids.txt", sep = "\t", quote=FALSE, row.names=FALSE, col.names=FALSE)

#Set2 Interpro Orai or found in CRAC fam profile search or found in TM psi search #250

Orai_set2<-Orai_initial %>% filter(., IP_ORAI ==TRUE | ! is.na(crac_fam_prof_search_minPval) | !is.na(true_orai_transmem_psi_search_minPval) ) %>% filter(., ! ID %in% ehuxisos)  %>% .$ID

write.table(Orai_set2, file="/data2/orai/putative/Orai_set2prot_ids.txt", sep = "\t", quote=FALSE, row.names=FALSE, col.names=FALSE)

#Set2 genomic

Orai_set2_genomic<-Orai_initial %>%  filter(., IP_ORAI ==TRUE | ! is.na(crac_fam_prof_search_minPval) | !is.na(true_orai_transmem_psi_search_minPval) )%>% filter(., genomic == TRUE) %>% filter(., ! ID %in% ehuxisos) %>%  .$ID
write.table(Orai_set2_genomic, file="/data2/orai/putative/Orai_set2_genomic_ids.txt", sep = "\t", quote=FALSE, row.names=FALSE, col.names=FALSE)

#Set2 hapista

Orai_set2_hapto<-Orai_initial %>%  filter(., IP_ORAI ==TRUE | ! is.na(crac_fam_prof_search_minPval) | !is.na(true_orai_transmem_psi_search_minPval) ) %>% filter(., hapista == TRUE) %>% filter(., ! ID %in% ehuxisos) %>%  .$ID
write.table(Orai_set2_hapto, file="/data2/orai/putative/Orai_set2_hapista_ids.txt", sep = "\t", quote=FALSE, row.names=FALSE, col.names=FALSE)

# Note: extract to fasta, then add the relevant additional seqs (human etc before doing alignments)

```



```{}

#On all ID lists run:

for i in Orai*ids.txt; do sed -i -r 's/(A0A.*)/\1_Coccolithus_braarudii/g' $i; done
 #make consistent with fast input

seqkit grep -f Orai_set1prot_ids.txt All_project_proteins.fasta | sed -r 's/>([^ ]*) .*$/>\1/g' | sed 's/*//g'  > set1_initial.fasta
cat set1_initial.fasta known_orai.fasta > set1.fasta

seqkit grep -f Orai_set2prot_ids.txt All_project_proteins.fasta | sed -r 's/>([^ ]*) .*$/>\1/g' | sed 's/*//g'  > set2_initial.fasta
cat set2_initial.fasta known_orai.fasta > set2.fasta
##
seqkit grep -f Orai_set1_genomic_ids.txt All_project_proteins.fasta | sed -r 's/>([^ ]*) .*$/>\1/g' | sed 's/*//g'  > set1_genomic.fasta
cat set1_genomic.fasta known_orai.fasta > set1.2genomic.fasta

seqkit grep -f Orai_set2_genomic_ids.txt All_project_proteins.fasta | sed -r 's/>([^ ]*) .*$/>\1/g' | sed 's/*//g'  > set2_genomic.fasta
cat set2_genomic.fasta known_orai.fasta > set2.2_genomic.fasta

seqkit grep -f Orai_set1_hapista_ids.txt All_project_proteins.fasta | sed -r 's/>([^ ]*) .*$/>\1/g' | sed 's/*//g'  > set1_hapista.fasta
cat set1_hapista.fasta known_orai.fasta > set1.3_hapista.fasta

seqkit grep -f Orai_set2_hapista_ids.txt All_project_proteins.fasta | sed -r 's/>([^ ]*) .*$/>\1/g' | sed 's/*//g'  > set2_hapista.fasta
cat set2_hapista.fasta known_orai.fasta > set2.3_hapista.fasta

```


Do initial alignment with MAFFT-dash and trim central region using Jalview.
From LSWRKLY ... QELNELA in the human sequences. Limits of near universal homology

yields ```set1.0_aln.fasta```

Don't realign wth mafft - makes alignment worse.


# Trees

Make annotation data

```{r}

prymnesiales<-c("EP00322_","EP00323_","EP00324_","EP00325_","EP00326_","EP00327_","EP00900_","EP00966_")
isochrysidales<-c("EhG.*\\.","Br.*\\.t1","EP00312_","EP00314_","EP00315_","EP00962_","EP00967_")
coccolithales<-c("EP00308_","EP00310_","EP00965_","s_braarudii")
syracosphaerales<-c("EP00316_")
zycodiscales<-c()#"EP00316_",
pavlovales<-c("EP00302_","EP00303_","EP00304_","EP00306_","EP00307_","EP00963_")
phaeocystales<-c("EP00320_","EP00908_","EP00964_","Phaglo1")
ancoracysta<-c("EP00164_")
centroplasthelida<-c("EP00298_","EP00299_","EP00300_","EP00301_")
diatoms<-c("EP00530_","EP00582_","EP00797_","EP00934_","EP00977_","EP01082_","_THAPS")
alveolata<-c("EP00425_","EP00427_","EP00428_","EP00429_","EP00822_","EP00829_") #dinos, cilliophora, plasmodium
foraminifera<-c("EP00480_") #rhizaria / SAR
archaeplastida<-c("EP00185_","EP00198_","EP00202_","EP00224_","_CHLRE","_PHYPA")
telonema<-c("EP00656_")
hemimastigophora<-c("EP00696_","EP00697_")
discoba<-c("EP00682_")
metamonida<-c("EP00770_")
ameobozoa<-c("EP00006_","EP00024_")
obozoa<-c("EP00046_","EP00134_","EP00136_","EP00144_")
Ancyromonadida<-c("EP00163_")

haptophytes<-c(prymnesiales, isochrysidales, coccolithales, syracosphaerales, pavlovales, phaeocystales)
hapista<-c(ancoracysta, centroplasthelida, haptophytes)
calcify<-c(coccolithales, syracosphaerales, "EhG.*\\.","Br.*\\.t1", "EP00314_","EP00315_")


```

basic. R91 mutation causes disease and disrupts
SRAKLKASSRT 
hydrophobic
LLSGFAMV
selectivity: MVEV
DADHD: calcium accumulating region, ensure ca influx even in low Ca conditions

whole region:
YLSRAKLKASSRTSALLSGFAMVAMVEVQLDADHD

Internal repeat homology - E106 equiv in TM3. E190
LAEVV

P245: TM4 bend, critical for conforomaional rearrangements
MVPF

TM4ex: antiparallel associaton between neigboring subunits and STIM1 coupling and ABP action. LVSHKT is nexus before TM4x
LVSHKTDRQFQELNELAEFARLQDQLDHRGD

STIM binding site in c terminus:
SLVSHKTDRQFQELNE

Li 2021
    • Constitutively active mutants: dOrai-H206A , dOrai-P288L
    • hOrai1-F257 in TM4, hOrai1-L261 in TM4 and hOrai1-F178A in TM3 (corresponding to F300, L304 and F250 in the dOrai channel, respectively), that interfere with the intra-subunit interactions between the TM3 and TM4 helices, cause a decrease in Ca2+ influx without attenuating the association of STIM1 with hOrai1
    • L81A, E173A and H169A mutants of hOrai1 obviously attenuate or abolish extracellular Ca2+ influx
    • mutations, such as R83A-K87A and R77A-K78A in the constitutively mutant hOrai1-P245L [39] and R155S/K159S/K163S in the open state dOrai-H206A [38], were introduced in the positively charged basic region to prevent electrostatic repulsion; these mutations greatly attenuate the influx of extracellular Ca2+. These results indicated that the basic region near the cytosolic face of the pore may play some unexpected but important roles in Ca2+ permeation.

```{r}

#read tree
set1.2gen_tree<-read.tree("set1.2_genomic_tree.nwk")

#use plotly to identify root node and reset
## plotly::ggplotly(p2)

set1.2gen_tree<-root(set1.2gen_tree, node=53) 

# make metadata dataframe for this set of sequences
set1.2gen_meta<-set1.2gen_tree$tip.label %>% as.data.frame() %>% set_colnames(c("ID")) %>%
  mutate(., group = case_when(
    str_detect(ID, paste(prymnesiales, collapse="|") ) ~ "Prymnesiales",
    str_detect(ID, paste(isochrysidales, collapse="|") ) ~ "Isochrysidales",
    str_detect(ID, paste(coccolithales, collapse="|") ) ~ "Coccolithales",
    str_detect(ID, paste(syracosphaerales, collapse="|") ) ~ "syracosphaerales",
    str_detect(ID, paste(pavlovales, collapse="|") ) ~ "Pavlovales",
    str_detect(ID, paste(phaeocystales, collapse="|") ) ~ "Phaeocystales",
    str_detect(ID, paste(ancoracysta, collapse="|") ) ~ "Ancoracysta",
    str_detect(ID, paste(centroplasthelida, collapse="|") ) ~ "Centroplasthelida",
    str_detect(ID, paste(diatoms, collapse="|") ) ~ "Diatoms",
    str_detect(ID, paste(alveolata, collapse="|") ) ~ "Alveolata",
    str_detect(ID, paste(foraminifera, collapse="|") ) ~ "Foraminifera",
    str_detect(ID, paste(archaeplastida, collapse="|") ) ~ "Archaeplastida",
    str_detect(ID, paste(telonema, collapse="|") ) ~ "Telonema",
    str_detect(ID, paste(hemimastigophora , collapse="|") ) ~ "Hemimastigophora",
    str_detect(ID, paste(discoba, collapse="|") ) ~ "Discoba",
    str_detect(ID, paste(metamonida, collapse="|") ) ~ "Metamonida",
    str_detect(ID, paste(ameobozoa, collapse="|") ) ~ "Ameobozoa",
    str_detect(ID, paste(obozoa, collapse="|") ) ~ "Obozoa",
    str_detect(ID, paste(Ancyromonadida, collapse="|") ) ~ "Ancyromonadida",
    .default = "Obozoa"  )) %>%
  mutate(., haptista = case_when(
    str_detect(ID, paste(hapista, collapse="|") ) ~ "Hapista",
  )) %>%
  mutate(., calcifier = case_when(
    str_detect(ID, paste(calcify, collapse="|") ) ~ "Calcifying",
  ))

#Get residue information from alignment

set1.2aln<-readAAStringSet("set1.2_genomic_aln.fasta", format="fasta") #readd aln
reference_seq <- as.character(set1.2aln[[2]]) #find human orai1

patt_pore <- "Y-*L-*S-*R-*A-*K-*L-*K-*A-*S-*S-*R-*T-*S-*A-*L-*L-*S-*G-*F-*A-*M-*V-*A-*M-*V-*E-*V-*Q-*L-*D-*A-*D-*H-*D-*"
patt_TM3<-"L-*A-*E-*V-*V-*"
patt_TM4Pro<-"M-*V-*P-*F-*"
patt_TM4ex<-"L-*V-*S-*H-*K-*T-*D-*R-*Q-*F-*Q-*E-*L-*N-*E-*L-*A-*E-*F-*A-*R-*L-*Q-*D-*Q-*L-*D-*H-*R-*G-*D-*"

patterns<-c(patt_pore, patt_TM3, patt_TM4Pro, patt_TM4ex)
  
regionlist<-list()
i<-0
for (p in patterns){
  i <- i + 1
  matches <- gregexpr(p, reference_seq, perl = TRUE)[[1]]
  match_start <- min( unlist(lapply(matches, function(m) m:(m + ((nchar(p) + 2) / 3) - 1))) ) %>% as.double()
  match_end <- match_start + ( attributes(matches) %>% .$match.length )
  tm<-c(match_start, match_end)
  regionlist[[i]]<-tm
}


#Plot tree

t1<-ggtree(set1.2gen_tree) %<+% set1.2gen_meta +
  geom_tippoint(aes(color=group), size=1.5) +
  geom_tiplab(aes(colour=group), size=2, nudge_x = 0.2, align=TRUE ) + 
  geom_nodelab(aes(label=label), hjust=-.05, size=2.0)  + 
  ggplot2::xlim(0, 14)


regions<-list(c(233,240),c(520,530))
regionlist

#Add msa

plot_tree_with_msa(t1, "set1.2_genomic_aln.fasta", regionlist, width=2, offset=3, spacing=0.05, bg_line = TRUE)





```


```{r, fig.width=40, fig.height = 10}

#plot_tree_with_msa(t1, "set1.2_genomic_aln.fasta", regionlist, width=0.05, offset=1, spacing=0.05, bg_line = TRUE)

plot_tree_with_msa(t1, "set1.2_genomic_aln.fasta", regionlist, width=1.3, offset=4, spacing=0.007, bg_line = TRUE, tree_ratio=0.25)

ggtree()
library(cowplot)

```

```{}
#code wastage
ggmsa("set1.2_genomic_aln.fasta", 233, 237, seq_name = FALSE, char_width = 0.5) + 
  geom_seqlogo(color = "Chemistry_AA")
msaplot(t1, "set1.2_genomic_aln.fasta", window=c(233,237), width=0.2, offset=5, bg_line = TRUE)

plot_tree_with_msa(t1, "set1.2_genomic_aln.fasta", window=c(233,237), width=0.2, offset=5, bg_line = TRUE)

ggtree(set1.2gen_tree) %<+% set1.2gen_meta +
  geom_highlight(data=set1.2genclades.df, 
                 aes(node=node, fill=clade),
                 alpha=1,
                 align="right",
                 extend=0.1,
                 show.legend=TRUE) +
  geom_tiplab(size=2) + 
  geom_nodelab(aes(label=label), hjust=-.05, size=3.5)  + 
  ggplot2::xlim(0, 14) +
  geom_rootedge() 
#Make dataframe for clade nodes
set1.2genclades.df <- data.frame(
  clade=unique(set1.2gen_meta$group),
  node=NA
)
#Find the most recent common ancestor for each clade
for (i in 1:length(set1.2genclades.df$clade)) {
  
  set1.2genclades.df$node[i] <- MRCA(
    set1.2gen_tree,
    set1.2gen_meta$ID[set1.2gen_meta$group == set1.2genclades.df$clade[i]]
    )
}


    # Trim the alignment to the specific columns
trimmed_alignment <- AAStringSet(lapply(set1.2aln, function(seq) {
    substring(seq, min(matched_columns), max(matched_columns))
}))

 paste(substring(set1.2aln[[2]], min(matched_columns), max(matched_columns)), collapse = "")

```


```{r}
# Define the amino acid chemical categories and corresponding colors
chem_categories <- list(
    "nonpolar" = c("A", "V", "L", "I", "M", "F", "W", "P", "G"),
    "polar" = c("S", "T", "C", "Y", "N", "Q"),
    "basic" = c("K", "R", "H"),
    "acidic" = c("D", "E"),
    "aromatic" = c("F", "W", "Y")
)

chem_colors <- c(
    "nonpolar" = "gold",
    "polar" = "green",
    "basic" = "blue",
    "acidic" = "red",
    "aromatic" = "purple",
    "-" = "white",  # gap
    "..." = "white" # gap between regions
)

# Function to categorize amino acids
categorize_amino_acid <- function(aa) {
    aa <- toupper(aa)
    for (category in names(chem_categories)) {
        if (aa %in% chem_categories[[category]]) {
            return(category)
        }
    }
    return(NA)  # For any character that doesn't match (shouldn't happen)
}

# Main function
plot_tree_with_msa <- function(p, fasta, regions, offset = 0, width = 5, spacing = 0.2, color = NULL, bg_line = TRUE, height = 0.8, tree_ratio = 0.5) {
    if (missing(fasta)) {
        x <- NULL
    } else if (is(fasta, "DNAbin") || is(fasta, "AAbin")) {
        x <- fasta
    } else if (is(fasta, "character")) {
        x <- treeio::read.fasta(fasta)
    } else {
        x <- NULL
    }
   
    if (is.null(x) && is(p, "treedata") && length(p@tip_seq)) {
        x <- p@tip_seq
        p <- ggtree(p) + geom_tiplab()
    }
   
    if (is.null(x)) {
        stop("multiple sequence alignment is not available...\n-> check the parameter 'fasta'...")
    }
   
    x <- as.matrix(x)
   
    if (!all(labels(x) %in% p$data$label)) {
        stop("taxa name in input sequences do not match with the ones on the tree, please check your input files...")
    }
   
    if (is.null(regions)) {
        stop("Please provide a list of regions to display.")
    }
   
    df <- p$data
    df <- df[df$isTip, ]
    seqs <- lapply(1:nrow(x), function(i) {
        seq <- as.vector(as.character(x[i, ]))
        seq[seq == "?"] <- "-"
        seq[seq == "*"] <- "-"
        seq[seq == " "] <- "-"
        return(seq)
    })
    names(seqs) <- labels(x)
    seqs <- seqs[df$label[order(df$y)]]
   
    combined_seqs <- lapply(seqs, function(seq) {
        combined <- unlist(lapply(regions, function(region) {
            start <- region[1]
            end <- region[2]
            c(seq[start:end], "...")
        }))
        combined <- combined[-length(combined)] # Remove last "..."
        combined <- str_trim(combined)  # Remove trailing white spaces
        return(combined)
    })
   
    if (is.null(color)) {
        unique_aa <- unique(unlist(combined_seqs))
        aa_categories <- sapply(unique_aa, categorize_amino_acid)
        color <- chem_colors[aa_categories]
        names(color) <- unique_aa
        color <- c(color, `-` = "white", `...` = "white")
    }
   
    width_factor <- width * (df$x %>% range %>% diff) / length(combined_seqs[[1]])
    y <- sort(df$y)
    h <- ceiling(diff(range(df$y)) / length(df$y))
    height_factor <- height / 2 * h
   
    slice <- seq_along(combined_seqs[[1]])
    msa_xmax <- offset + seq_along(slice) * (width_factor + spacing)
    msa_xmin <- msa_xmax - (width_factor + spacing)
    ymin <- y - height_factor
    ymax <- y + height_factor
   
    msa_df <- do.call("rbind", lapply(1:length(y), function(i) {
        data.frame(
            name = names(combined_seqs)[i],
            xmin = msa_xmin,
            xmax = msa_xmax,
            ymin = ymin[i],
            ymax = ymax[i],
            seq = combined_seqs[[i]],
            chem_category = sapply(combined_seqs[[i]], categorize_amino_acid)
        )
    }))
   
    if (bg_line) {
        line_segments <- msa_df %>%
            group_by(ymin) %>%
            summarize(xmin = min(xmin), xmax = max(xmax), .groups = 'drop')
        p <- p + geom_segment(data = line_segments, aes(x = xmin, xend = xmax, y = ymin, yend = ymin),
                              linewidth = h * 0.2, inherit.aes = FALSE)
    }
   
    # Dynamically adjust text size based on MSA width
    text_size <- min(3, 3 * length(slice) / 50)  # Adjust as needed
   
    p_msa <- ggplot(msa_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = chem_category)) +
        geom_rect() +
        geom_text(aes(x = (xmin + xmax) / 2, y = (ymin + ymax) / 2, label = toupper(seq)),
                  size = text_size, inherit.aes = FALSE) +
        scale_fill_manual(values = chem_colors, na.value = "white") +
        theme_void() +
        facet_wrap(~ name, ncol = 1, scales = "free_y")
   
    combined_plot <- cowplot::plot_grid(
        p + theme(plot.margin = margin(r = 5)),
        p_msa + theme(plot.margin = margin(l = 5)),
        rel_widths = c(tree_ratio, 1 - tree_ratio)
    )
   
    return(combined_plot)
}
```



```{r}

# Define the amino acid chemical categories and corresponding colors
chem_categories <- list(
    "nonpolar" = c("A", "V", "L", "I", "M", "F", "W", "P", "G"),
    "polar" = c("S", "T", "C", "Y", "N", "Q"),
    "basic" = c("K", "R", "H"),
    "acidic" = c("D", "E"),
    "aromatic" = c("F", "W", "Y")
)

chem_colors <- c(
    "nonpolar" = "gold",
    "polar" = "green",
    "basic" = "blue",
    "acidic" = "red",
    "aromatic" = "purple",
    "-" = "white",  # gap
    "..." = "white" # gap between regions
)

# Function to categorize amino acids
categorize_amino_acid <- function(aa) {
    aa <- toupper(aa)
    for (category in names(chem_categories)) {
        if (aa %in% chem_categories[[category]]) {
            return(category)
        }
    }
    return(NA)  # For any character that doesn't match (shouldn't happen)
}

# Main function
plot_tree_with_msa <- function(p, fasta, regions, offset = 0, width = 5, spacing = 0.2, color = NULL, bg_line = TRUE, height = 0.8, tree_ratio = 0.5, text_size=3) {
    if (missing(fasta)) {
        x <- NULL
    } else if (is(fasta, "DNAbin") || is(fasta, "AAbin")) {
        x <- fasta
    } else if (is(fasta, "character")) {
        x <- treeio::read.fasta(fasta)
    } else {
        x <- NULL
    }
   
    if (is.null(x) && is(p, "treedata") && length(p@tip_seq)) {
        x <- p@tip_seq
        p <- ggtree(p) + geom_tiplab()
        
        # gt = ggplot_gtable(ggplot_build(p))
        # gtcol<-gt$layout$l[grep('panel', gt$layout$name)] #
        # gt$widths[gtcol] = tree_ratio*gt$widths[gtcol] # set width to tree_ratio
        # p<-grid.draw(gt) # plot with grid draw
    }
   
    if (is.null(x)) {
        stop("multiple sequence alignment is not available...\n-> check the parameter 'fasta'...")
    }
   
    x <- as.matrix(x)
   
    if (!all(labels(x) %in% p$data$label)) {
        stop("taxa name in input sequences do not match with the ones on the tree, please check your input files...")
    }
   
    if (is.null(regions)) {
        stop("Please provide a list of regions to display.")
    }
   
    df <- p$data
    df <- df[df$isTip, ]
    seqs <- lapply(1:nrow(x), function(i) {
        seq <- as.vector(as.character(x[i, ]))
        seq[seq == "?"] <- "-"
        seq[seq == "*"] <- "-"
        seq[seq == " "] <- "-"
        return(seq)
    })
    names(seqs) <- labels(x)
    seqs <- seqs[df$label[order(df$y)]]
   
    combined_seqs <- lapply(seqs, function(seq) {
        combined <- unlist(lapply(regions, function(region) {
            start <- region[1]
            end <- region[2]
            c(seq[start:end], "...")
        }))
        combined <- combined[-length(combined)] # Remove last "..."
        combined <- str_trim(combined)  # Remove trailing white spaces
        return(combined)
    })
   
    if (is.null(color)) {
        unique_aa <- unique(unlist(combined_seqs))
        aa_categories <- sapply(unique_aa, categorize_amino_acid)
        color <- chem_colors[aa_categories]
        names(color) <- unique_aa
        color <- c(color, `-` = "white", `...` = "white")
    }
   
    # Compute width factors based on tree_ratio
    tree_width <- max(df$x) * tree_ratio
    msa_width <- tree_width / tree_ratio * (1 - tree_ratio)
   
    width_factor <- width * (df$x %>% range %>% diff) / length(combined_seqs[[1]])
    y <- sort(df$y)
    h <- ceiling(diff(range(df$y)) / length(df$y))
    height_factor <- height / 2 * h
   
    slice <- seq_along(combined_seqs[[1]])
    xmax <- tree_width + offset + seq_along(slice) * (width_factor + spacing)
    xmin <- xmax - (width_factor + spacing)
    ymin <- y - height_factor
    ymax <- y + height_factor
   
    msa_df <- do.call("rbind", lapply(1:length(y), function(i) {
        data.frame(
            name = names(combined_seqs)[i],
            xmin = xmin,
            xmax = xmax,
            ymin = ymin[i],
            ymax = ymax[i],
            seq = combined_seqs[[i]],
            chem_category = sapply(combined_seqs[[i]], categorize_amino_acid)
        )
    }))
   
    if (bg_line) {
        line_segments <- msa_df %>%
            group_by(ymin) %>%
            summarize(xmin = min(xmin), xmax = max(xmax), .groups = 'drop')
        p <- p + geom_segment(data = line_segments, aes(x = xmin, xend = xmax, y = ymin, yend = ymin),
                              linewidth = h * 0.2, inherit.aes = FALSE)
    }
   
    # Dynamically adjust text size based on MSA width
    #text_size <-3 #min(3, 3 * msa_width / 10)  # Adjust as needed
   
    p <- p +
        geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = chem_category),
                  data = msa_df, inherit.aes = FALSE) +
        geom_text(aes(x = (xmin + xmax) / 2, y = (ymin + ymax) / 2, label = toupper(seq)),
                  data = msa_df, inherit.aes = FALSE, size = text_size) +
        scale_fill_manual(values = chem_colors, na.value = "white")
    browser()
        gt = ggplot_gtable(ggplot_build(p))
        gtcol<-gt$layout$l[grep('panel', gt$layout$name)] #
        gt$widths[gtcol] = tree_ratio*gt$widths[gtcol] # set width to tree_ratio
        p<-grid.draw(gt) # plot with grid draw
    
    return(p)
}

```

```{r}
library(gtable)
library(grid)
```


```{r}
# Define the amino acid chemical categories and corresponding colors
chem_categories <- list(
    "nonpolar" = c("A", "V", "L", "I", "M", "F", "W", "P", "G"),
    "polar" = c("S", "T", "C", "Y", "N", "Q"),
    "basic" = c("K", "R", "H"),
    "acidic" = c("D", "E"),
    "aromatic" = c("F", "W", "Y")
)

chem_colors <- c(
    "nonpolar" = "gold",
    "polar" = "green",
    "basic" = "blue",
    "acidic" = "red",
    "aromatic" = "purple",
    "-" = "white",  # gap
    "..." = "white" # gap between regions
)

# Function to categorize amino acids
categorize_amino_acid <- function(aa) {
    aa <- toupper(aa)
    for (category in names(chem_categories)) {
        if (aa %in% chem_categories[[category]]) {
            return(category)
        }
    }
    return(NA)  # For any character that doesn't match (shouldn't happen)
}



# Main function
plot_tree_with_msa <- function(p, fasta, regions, offset = 0, width = 5, spacing = 0.2, color = NULL, bg_line = TRUE, height = 0.8) {
    if (missing(fasta)) {
        x <- NULL
    } else if (is(fasta, "DNAbin") || is(fasta, "AAbin")) {
        x <- fasta
    } else if (is(fasta, "character")) {
        x <- treeio::read.fasta(fasta)
    } else {
        x <- NULL
    }
   
    if (is.null(x) && is(p, "treedata") && length(p@tip_seq)) {
        x <- p@tip_seq
        p <- ggtree(p) + geom_tiplab()
    }
   
    if (is.null(x)) {
        stop("multiple sequence alignment is not available...\n-> check the parameter 'fasta'...")
    }
   
    x <- as.matrix(x)
   
    if (!all(labels(x) %in% p$data$label)) {
        stop("taxa name in input sequences do not match with the ones on the tree, please check your input files...")
    }
   
    if (is.null(regions)) {
        stop("Please provide a list of regions to display.")
    }
   
    df <- p$data
    df <- df[df$isTip, ]
    seqs <- lapply(1:nrow(x), function(i) {
        seq <- as.vector(as.character(x[i, ]))
        seq[seq == "?"] <- "-"
        seq[seq == "*"] <- "-"
        seq[seq == " "] <- "-"
        return(seq)
    })
    names(seqs) <- labels(x)
    seqs <- seqs[df$label[order(df$y)]]
   
    combined_seqs <- lapply(seqs, function(seq) {
        combined <- unlist(lapply(regions, function(region) {
            start <- region[1]
            end <- region[2]
            c(seq[start:end], "...")
        }))
        combined <- combined[-length(combined)] # Remove last "..."
        combined <- str_trim(combined)  # Remove trailing white spaces
        return(combined)
    })
    browser()
   
    if (is.null(color)) {
        unique_aa <- unique(unlist(combined_seqs))
        aa_categories <- sapply(unique_aa, categorize_amino_acid)
        color <- chem_colors[aa_categories]
        names(color) <- unique_aa
        color <- c(color, `-` = "white", `...` = "white")
    }
   
    width_factor <- width * (df$x %>% range %>% diff) / length(combined_seqs[[1]])
    y <- sort(df$y)
    h <- ceiling(diff(range(df$y)) / length(df$y))
    height_factor <- height / 2 * h
   
    slice <- seq_along(combined_seqs[[1]])
    xmax <- max(df$x) * 1.02 + offset + seq_along(slice) * (width_factor + spacing)
    xmin <- xmax - (width_factor + spacing)
    ymin <- y - height_factor
    ymax <- y + height_factor
   
    msa_df <- do.call("rbind", lapply(1:length(y), function(i) {
        data.frame(
            name = names(combined_seqs)[i],
            xmin = xmin,
            xmax = xmax,
            ymin = ymin[i],
            ymax = ymax[i],
            seq = combined_seqs[[i]],
            chem_category = sapply(combined_seqs[[i]], categorize_amino_acid)
        )
    }))
   
    if (bg_line) {
        line_segments <- msa_df %>%
            group_by(ymin) %>%
            summarize(xmin = min(xmin), xmax = max(xmax), .groups = 'drop')
        p <- p + geom_segment(data = line_segments, aes(x = xmin, xend = xmax, y = ymin, yend = ymin),
                              linewidth = h * 0.2, inherit.aes = FALSE)
    }
   
    p <- p +
        geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = chem_category),
                  data = msa_df, inherit.aes = FALSE) +
        geom_text(aes(x = (xmin + xmax) / 2, y = (ymin + ymax) / 2, label = toupper(seq)),
                  data = msa_df, inherit.aes = FALSE, size = 3) +
        scale_fill_manual(values = chem_colors, na.value = "white")
   
    return(p)
}
```



```{r}
# CREATE A TREE -------------------------------------------------------------
n_samples <- 20
n_grp <- 4
tree <- ape::rtree(n = n_samples)

# CREATE SOME METADATA ----------------------------------------------------
id <- tree$tip.label
set.seed(42)
grp <- sample(LETTERS[1:n_grp], size = n_samples, replace = T)
dat <- tibble::tibble(id = id,
                      grp = grp)

# PLOT THE TREE -----------------------------------------------------------
p1 <- ggtree(tree)

metat <- p1$data %>%
  dplyr::inner_join(dat, c('label' = 'id'))

p2 <- p1 +
  geom_point(data = metat,
             aes(x = x,
                 y = y,
                 colour = grp,
                 label = id))

plotly::ggplotly(p2)
```


# Set1

Do initial MAFT / dash alignment
Identify main TM region: 557-1262





Set 1 next steps

- check and remove Ehux isoforms
- set1.0 -> manual end trim  -> IQtree

- set1.2 -> select genomic only -> aln -> manual end trim -> IQtree
- set 1.3 -> haptophyte only -> aln -> manual end trim -> IQtree

- set 1.3 -> haptophyte only full length -> aln -> manual end trim  -> IQtree

  tree annotations
  - annotate with key residues in alnment
  - colour clades by phylogenetic group

Questions:
- Are there orthogroups restricted to particular clades (e.g. calcifying haptophyes)
- Relationships between clades and key residues
- evidence of expansion of group? Or emergence of new genes (duplication?)
- structural modelling of representative sequences for clades = how might properties differ?

Set 2 next steps:

- remove Ehux isoforms
- remove wierd seqs (e.g. chlamu + others after initial alignment)

- set2.0 all seqs, end trimmed -> mafft -> IQtree
- set2.2 genomic only -> aln -> IQtree
- set 2.3 haptophyte only -> aln -> IQtree
- set 2.5 haptophyte only full length -> mafft -> IQtree

Figures:

Summary trees with collapsed nodes and key annotations
Protein primary structural diagrams
Protein 3D structural comparisons




```{}
NOT USEd
#download: set1_initial_aln.fasta
# Get main region

seqkit subseq -r 557:1262 set1_initial_aln.fasta > set1_initial_aln_trim.fasta

#remove aln positions:
sed -r 's/-//g' set1_initial_aln_trim.fasta | seqtk seq > set1_initial_aln_trim_tidy.fasta


```



